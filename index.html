<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contract editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 리셋 및 설정 */
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: 'Noto Sans KR', sans-serif; background-color: #f3f4f6; color: #1f2937; height: 100vh; overflow: hidden; }
        
        /* 레이아웃 */
        .app-container { display: flex; height: 100%; }
        
        /* 사이드바 */
        .sidebar { width: 320px; background: white; border-right: 1px solid #e5e7eb; display: flex; flex-direction: column; z-index: 10; flex-shrink: 0; }
        .sidebar-header { padding: 16px 20px; border-bottom: 1px solid #e5e7eb; }
        .sidebar-header h1 { margin: 0; font-size: 1.15rem; font-weight: 700; color: #1f2937; }
        
        /* 사이드바 컨텐츠 */
        .sidebar-content { 
            flex: 1; 
            overflow-y: auto; 
            padding: 16px 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
        }
        
        .section-title { font-size: 0.8rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 10px; }
        
        /* 파일 업로드 버튼 */
        .file-input-wrapper { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 8px; }
        .file-input-wrapper:hover { background: #f3f4f6; }
        .file-label { display: flex; align-items: center; gap: 12px; }
        .file-icon { color: #9ca3af; display: flex; align-items: center; } /* 아이콘 스타일 추가 */
        .file-desc h3 { margin: 0; font-size: 0.85rem; font-weight: 500; }
        .file-desc p { margin: 0; font-size: 0.7rem; color: #9ca3af; }
        
        /* 편집 모드 버튼 */
        .mode-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .mode-btn { 
            padding: 10px 4px; 
            border-radius: 6px; 
            font-weight: 500; 
            cursor: pointer; 
            border: 1px solid #e5e7eb; 
            background: #f9fafb; 
            color: #4b5563; 
            transition: all 0.2s; 
            font-size: 0.85rem; 
        }
        .mode-btn:hover { background: #f3f4f6; }
        .mode-btn.active { background: #eff6ff; color: #2563eb; border-color: #bfdbfe; font-weight: 600; }
        
        /* 슬라이더 컨트롤 */
        .control-group { margin-bottom: 12px; }
        .control-header { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 6px; }
        .range-input { width: 100%; height: 4px; background: #e5e7eb; border-radius: 5px; outline: none; -webkit-appearance: none; }
        .range-input::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #2563eb; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        /* 하단 액션 버튼 */
        .sidebar-footer { padding: 16px 20px; border-top: 1px solid #e5e7eb; background: #f9fafb; display: flex; flex-direction: column; gap: 8px; }
        .action-btn { width: 100%; padding: 12px; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.2s; border: none; font-size: 0.95rem; }
        .btn-undo { background: white; border: 1px solid #d1d5db; color: #374151; }
        .btn-undo:hover { background: #f3f4f6; }
        .btn-undo:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-save { background: #2563eb; color: white; box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.3); }
        .btn-save:hover { background: #1d4ed8; transform: translateY(-1px); }
        .btn-save:disabled { opacity: 0.5; cursor: not-allowed; background: #9ca3af; box-shadow: none; transform: none; }

        /* 메인 캔버스 영역 */
        .main-area { flex: 1; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        .canvas-container { 
            flex: 1; 
            overflow: hidden; 
            background-color: #e5e7eb; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 0; 
            position: relative;
            transition: background-color 0.2s;
            cursor: pointer; /* 빈 상태일 때 클릭 가능함을 표시 */
        }
        /* 이미지가 로드되면 커서 변경 (JS로 제어) */
        .canvas-container.loaded {
            cursor: default;
        }
        .canvas-container.drag-over {
            background-color: #dbeafe;
            border: 4px dashed #2563eb;
        }

        .empty-state { text-align: center; pointer-events: none; }
        .empty-icon { font-size: 2rem; color: #9ca3af; margin-bottom: 10px; font-weight: bold; }
        
        canvas { 
            background: white; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); 
            display: block; 
            transition: transform 0.1s ease-out; 
        }
        
        /* 커서 스타일 */
        .cursor-crosshair { cursor: crosshair; }
        .cursor-text { cursor: text; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab !important; }
        .cursor-grabbing { cursor: grabbing !important; }

        /* 우측 하단 플로팅 컨트롤 컨테이너 */
        .floating-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            z-index: 20;
        }

        /* 도움말 버튼 */
        .help-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #2563eb;
            color: white;
            border: none;
            box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            transition: transform 0.2s, background-color 0.2s;
        }
        .help-btn:hover {
            background-color: #1d4ed8;
            transform: scale(1.05);
        }

        /* 줌 컨트롤 패널 */
        .zoom-controls { 
            background: white; 
            border-radius: 12px; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
            border: 1px solid #e5e7eb; 
            width: 50px; 
        }
        .zoom-btn { 
            padding: 12px 0; 
            width: 100%;
            background: white; 
            border: none; 
            cursor: pointer; 
            font-weight: bold; 
            color: #4b5563; 
            transition: background 0.2s; 
            font-size: 1.2rem; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .zoom-btn:hover { background: #f3f4f6; }
        .zoom-btn.active { background: #eff6ff; color: #2563eb; }
        .zoom-display { 
            padding: 8px 0;
            width: 100%;
            font-size: 0.75rem; 
            text-align: center; 
            color: #9ca3af; 
            border-top: 1px solid #e5e7eb; 
            border-bottom: 1px solid #e5e7eb; 
            background: #f9fafb; 
            font-family: monospace; 
        }
        
        /* 안내 메시지 */
        .zoom-guide {
            position: absolute;
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20; 
            white-space: nowrap;
        }
        .zoom-guide.visible { opacity: 1; }

        /* 공통 모달 스타일 */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(2px); display: none; align-items: center; justify-content: center; z-index: 50; }
        .modal-content { background: white; padding: 24px; border-radius: 16px; width: 380px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); max-height: 90vh; overflow-y: auto; }
        
        /* 입력 모달 전용 */
        .input-modal-content { width: 380px; }
        .modal-title { font-size: 1.125rem; font-weight: 700; color: #111827; margin-bottom: 5px; display: flex; align-items: center; gap: 5px; }
        .modal-title span { color: #2563eb !important; }
        .modal-desc { font-size: 0.875rem; color: #6b7280; margin-bottom: 20px; }
        .modal-input { width: 100%; padding: 12px 16px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 1.125rem; text-align: center; margin-bottom: 20px; outline: none; font-weight: 500; }
        .modal-input:focus { border-color: #2563eb; box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1); }
        .modal-actions { display: flex; gap: 10px; }
        .modal-btn { flex: 1; padding: 12px; border-radius: 10px; font-weight: 600; cursor: pointer; border: none; font-size: 1rem; }
        .btn-cancel { background: #f3f4f6; color: #4b5563; }
        .btn-confirm { background: #2563eb; color: white; }

        /* 도움말 모달 전용 */
        .help-modal-content { width: 500px; padding: 30px; position: relative; }
        .help-section { margin-bottom: 20px; }
        .help-section h3 { font-size: 1rem; font-weight: 700; color: #2563eb; margin: 0 0 8px 0; }
        .help-section p, .help-section ul { font-size: 0.9rem; color: #4b5563; line-height: 1.5; margin: 0; padding-left: 20px; }
        .help-section ul { list-style-type: disc; }
        .help-close-btn { position: absolute; top: 20px; right: 20px; background: none; border: none; cursor: pointer; color: #9ca3af; }
        .help-close-btn:hover { color: #1f2937; }

        /* 숨김처리 */
        .hidden { display: none; }
    </style>
</head>
<body>

<div class="app-container">
    <!-- 사이드바 -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <h1>Contract editor</h1>
        </div>

        <div class="sidebar-content">
            <!-- 파일 관리 섹션 -->
            <div>
                <div class="section-title">파일 관리</div>
                
                <label class="file-input-wrapper">
                    <div class="file-label">
                        <!-- 이미지 아이콘 (회색) -->
                        <div class="file-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                        </div>
                        <div class="file-desc">
                            <h3>계약서 불러오기</h3>
                            <p>JPG, PNG 파일</p>
                        </div>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" class="hidden">
                </label>
            </div>

            <!-- 편집 모드 섹션 -->
            <div>
                <div class="section-title">편집 모드</div>
                <div class="mode-buttons">
                    <button id="btnModeLine" class="mode-btn active">가로선 수정</button>
                    <button id="btnModeText" class="mode-btn">텍스트 작성</button>
                    <button id="btnModeX" class="mode-btn">X 표시</button>
                    <button id="btnModeV" class="mode-btn">V 표시</button>
                </div>
                <p style="font-size: 0.75rem; color: #6b7280; margin-top: 8px;" id="modeDesc">마우스로 드래그하여 가로선을 긋고 수정합니다.</p>
            </div>

            <!-- 스타일 설정 섹션 -->
            <div>
                <div class="section-title" id="styleTitle">스타일 설정</div>
                
                <div class="control-group">
                    <div class="control-header">
                        <span>크기 설정</span>
                        <span id="fontSizeVal">24px</span>
                    </div>
                    <input type="range" id="fontSizeRange" class="range-input" min="10" max="100" value="24">
                </div>

                <div class="control-group" id="stampSizeControl">
                    <div class="control-header">
                        <span>도장 크기</span>
                        <span id="stampSizeVal">60px</span>
                    </div>
                    <input type="range" id="stampSizeRange" class="range-input" min="20" max="150" value="60">
                </div>
                
                <div class="control-group" id="stampPosControl">
                    <div class="control-header">
                        <span>도장 위치</span>
                        <span id="stampPosVal">35px</span>
                    </div>
                    <input type="range" id="stampPosRange" class="range-input" min="-100" max="200" value="35">
                </div>

                <div class="control-group" id="offsetControl">
                    <div class="control-header">
                        <span>글자 높이 간격</span>
                        <span id="offsetVal">15px</span>
                    </div>
                    <input type="range" id="offsetRange" class="range-input" min="0" max="50" value="15">
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
            <div style="display: flex; gap: 10px;">
                <button id="undoBtn" class="action-btn btn-undo" disabled style="flex: 1;">실행 취소</button>
                <button id="resetBtn" class="action-btn btn-undo" disabled style="flex: 1;">수정 초기화</button>
            </div>
            <button id="saveBtn" class="action-btn btn-save" disabled>JPG 저장</button>
        </div>
    </aside>

    <!-- 메인 영역 -->
    <main class="main-area">
        <!-- 우측 하단 플로팅 컨트롤 (도움말 + 줌) -->
        <div class="floating-controls">
            <button id="helpBtn" class="help-btn" title="사용 설명서">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
            </button>

            <div id="zoomControls" class="zoom-controls hidden">
                <button id="zoomIn" class="zoom-btn" title="확대">+</button>
                <div id="zoomLevel" class="zoom-display">100%</div>
                <button id="zoomOut" class="zoom-btn" title="축소">-</button>
                <div style="height: 1px; background: #e5e7eb; width: 100%;"></div>
                <button id="btnHandTool" class="zoom-btn" title="화면 이동 (패닝)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
                </button>
            </div>
        </div>
        
        <div id="zoomGuide" class="zoom-guide hidden">Spacebar 또는 손 도구를 사용하여 이동</div>

        <div class="canvas-container" id="canvasContainer">
            <div id="emptyState" class="empty-state">
                <div class="empty-icon">Upload</div>
                <h3 style="margin: 0; color: #4b5563;">클릭 또는 드래그하여<br>계약서 파일을 불러오세요</h3>
            </div>
            <canvas id="mainCanvas" class="hidden"></canvas>
        </div>
    </main>
</div>

<!-- 입력 모달 -->
<div id="inputModal" class="modal-overlay">
    <div class="modal-content input-modal-content">
        <h3 class="modal-title"><span>[입력]</span> 수정할 내용 입력</h3>
        <p class="modal-desc">숫자를 입력하면 자동으로 콤마가 적용됩니다.</p>
        <input type="text" id="textInput" class="modal-input" placeholder="예: 15,000,000">
        <div class="modal-actions">
            <button id="modalCancel" class="modal-btn btn-cancel">취소</button>
            <button id="modalConfirm" class="modal-btn btn-confirm">입력 확인</button>
        </div>
    </div>
</div>

<!-- 도움말 모달 -->
<div id="helpModal" class="modal-overlay">
    <div class="modal-content help-modal-content">
        <button id="helpCloseBtn" class="help-close-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
        
        <h2 style="margin-top: 0; color: #111827; font-size: 1.5rem;">사용 설명서</h2>
        <hr style="border: 0; border-top: 1px solid #e5e7eb; margin: 15px 0 20px 0;">

        <div class="help-section">
            <h3>1. 시작하기</h3>
            <p>중앙 화면을 <strong>클릭</strong>하여 파일을 선택하거나, 계약서 이미지를 <strong>드래그</strong>하여 불러오세요.</p>
        </div>

        <div class="help-section">
            <h3>2. 수정 모드 사용법</h3>
            <ul>
                <li><strong>가로선 수정:</strong> 금액/내용을 변경할 때 사용합니다. 마우스로 드래그하여 줄을 긋고 새로운 내용을 입력하세요.</li>
                <li><strong>텍스트 작성:</strong> 빈 공간에 새로운 내용을 추가할 때 사용합니다. 원하는 위치를 클릭하세요.</li>
                <li><strong>X / V 표시:</strong> 체크나 선택이 필요할 때 사용합니다. 원하는 위치를 클릭하면 표시됩니다.</li>
            </ul>
        </div>

        <div class="help-section">
            <h3>3. 화면 조작 및 기타</h3>
            <ul>
                <li><strong>화면 이동:</strong> Spacebar를 누르거나 우측 하단 <strong>손 아이콘</strong>을 클릭한 후 드래그하세요.</li>
                <li><strong>삭제:</strong> 수정된 항목 위에 마우스를 올리면 나타나는 <strong>빨간색 X</strong>를 클릭하세요.</li>
                <li><strong>저장:</strong> 모든 작업 후 좌측 하단 <strong>[JPG 저장]</strong> 버튼을 누르세요.</li>
            </ul>
        </div>
    </div>
</div>

<script>
    // --- State Variables ---
    let image = null;
    let stampImage = null; // Will be loaded on init
    let modifications = [];
    let editMode = 'line'; // 'line', 'text', 'x-mark', 'v-mark'
    
    let isDrawing = false;
    let currentStart = null;
    let currentEnd = null;
    
    // Zoom & Pan State
    let zoom = 1;
    let panX = 0;
    let panY = 0;
    let isSpacePressed = false;
    let isHandToolMode = false;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    
    // Hover & Delete State
    let hoveredItemId = null;
    let deleteBtnHit = false;
    
    // 개별 스타일 설정
    const styleSettings = {
        line: { fontSize: 24, stampSize: 30, offset: 15, stampPos: 35 }, 
        text: { fontSize: 24, stampSize: 50, offset: 0, stampPos: 35 },  
        'x-mark': { fontSize: 12, stampSize: 0, offset: 0, stampPos: 0 }, 
        'v-mark': { fontSize: 12, stampSize: 0, offset: 0, stampPos: 0 } 
    };
    
    let pendingModification = null;

    // --- DOM Elements ---
    const imageInput = document.getElementById('imageInput');
    const btnModeLine = document.getElementById('btnModeLine');
    const btnModeText = document.getElementById('btnModeText');
    const btnModeX = document.getElementById('btnModeX');
    const btnModeV = document.getElementById('btnModeV');
    const modeDesc = document.getElementById('modeDesc');
    const offsetControl = document.getElementById('offsetControl');
    const stampSizeControl = document.getElementById('stampSizeControl');
    const stampPosControl = document.getElementById('stampPosControl');
    const fontSizeRange = document.getElementById('fontSizeRange');
    const fontSizeVal = document.getElementById('fontSizeVal');
    const stampSizeRange = document.getElementById('stampSizeRange');
    const stampSizeVal = document.getElementById('stampSizeVal');
    const stampPosRange = document.getElementById('stampPosRange');
    const stampPosVal = document.getElementById('stampPosVal');
    const offsetRange = document.getElementById('offsetRange');
    const offsetVal = document.getElementById('offsetVal');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const saveBtn = document.getElementById('saveBtn');
    const zoomControls = document.getElementById('zoomControls');
    const zoomIn = document.getElementById('zoomIn');
    const zoomOut = document.getElementById('zoomOut');
    const btnHandTool = document.getElementById('btnHandTool');
    const zoomLevel = document.getElementById('zoomLevel');
    const zoomGuide = document.getElementById('zoomGuide');
    const canvasContainer = document.getElementById('canvasContainer');
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const emptyState = document.getElementById('emptyState');
    const inputModal = document.getElementById('inputModal');
    const textInput = document.getElementById('textInput');
    const modalCancel = document.getElementById('modalCancel');
    const modalConfirm = document.getElementById('modalConfirm');
    
    // Help Modal Elements
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const helpCloseBtn = document.getElementById('helpCloseBtn');

    // --- Load Default Stamp on Init ---
    const defaultStampUrl = "https://gi.esmplus.com/ca1339/signature.png";
    const defaultStamp = new Image();
    defaultStamp.crossOrigin = "Anonymous"; 
    defaultStamp.src = defaultStampUrl;
    defaultStamp.onload = () => {
        stampImage = defaultStamp;
    };

    // --- Help Modal Logic ---
    helpBtn.addEventListener('click', () => { helpModal.style.display = 'flex'; });
    helpCloseBtn.addEventListener('click', () => { helpModal.style.display = 'none'; });
    // Close modal when clicking outside content
    helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) helpModal.style.display = 'none';
    });

    // --- Drag & Drop & Click Handlers ---
    
    // Click to upload (when empty)
    canvasContainer.addEventListener('click', (e) => {
        if (!image) {
            imageInput.click();
        }
    });

    canvasContainer.addEventListener('dragover', (e) => { e.preventDefault(); canvasContainer.classList.add('drag-over'); });
    canvasContainer.addEventListener('dragleave', (e) => { e.preventDefault(); canvasContainer.classList.remove('drag-over'); });
    canvasContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        canvasContainer.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) loadFile(file);
        else alert('이미지 파일(JPG, PNG 등)만 올려주세요.');
    });

    // --- Event Listeners: File Upload ---
    imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) loadFile(file);
    });

    function loadFile(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                image = img;
                modifications = [];
                initCanvas();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    // --- Event Listeners: Mode Switching ---
    btnModeLine.addEventListener('click', () => setMode('line'));
    btnModeText.addEventListener('click', () => setMode('text'));
    btnModeX.addEventListener('click', () => setMode('x-mark'));
    btnModeV.addEventListener('click', () => setMode('v-mark'));

    function setMode(mode) {
        editMode = mode;
        [btnModeLine, btnModeText, btnModeX, btnModeV].forEach(btn => btn.classList.remove('active'));
        
        offsetControl.style.display = 'none';
        stampSizeControl.style.display = 'none';
        stampPosControl.style.display = 'none';

        // UI Update from settings
        fontSizeRange.value = styleSettings[mode].fontSize;
        fontSizeVal.innerText = styleSettings[mode].fontSize + 'px';
        stampSizeRange.value = styleSettings[mode].stampSize;
        stampSizeVal.innerText = styleSettings[mode].stampSize + 'px';
        stampPosRange.value = styleSettings[mode].stampPos;
        stampPosVal.innerText = styleSettings[mode].stampPos + 'px';
        offsetRange.value = styleSettings[mode].offset;
        offsetVal.innerText = styleSettings[mode].offset + 'px';

        if (mode === 'line') {
            btnModeLine.classList.add('active');
            modeDesc.innerText = '마우스로 드래그하여 가로선을 긋고 수정합니다.';
            offsetControl.style.display = 'block';
            stampSizeControl.style.display = 'block';
            stampPosControl.style.display = 'block';
            textInput.placeholder = "예: 15,000,000";
        } else if (mode === 'text') {
            btnModeText.classList.add('active');
            modeDesc.innerText = '원하는 위치를 클릭하여 텍스트를 입력합니다.';
            stampSizeControl.style.display = 'block';
            stampPosControl.style.display = 'block';
            textInput.placeholder = "텍스트 입력";
        } else if (mode === 'x-mark') {
            btnModeX.classList.add('active');
            modeDesc.innerText = '원하는 위치를 클릭하여 X 표시를 남깁니다.';
        } else if (mode === 'v-mark') {
            btnModeV.classList.add('active');
            modeDesc.innerText = '원하는 위치를 클릭하여 V 표시를 남깁니다.';
        }
        updateCursor();
    }
    
    // Toggle Hand Tool
    btnHandTool.addEventListener('click', () => {
        isHandToolMode = !isHandToolMode;
        isHandToolMode ? btnHandTool.classList.add('active') : btnHandTool.classList.remove('active');
        updateCursor();
    });

    function updateCursor() {
        if (isSpacePressed || isHandToolMode) {
            canvas.classList.remove('cursor-crosshair', 'cursor-text', 'cursor-pointer');
            canvas.classList.add('cursor-grab');
            if (isPanning) canvas.classList.add('cursor-grabbing');
            else canvas.classList.remove('cursor-grabbing');
            return;
        }

        canvas.classList.remove('cursor-grab', 'cursor-grabbing', 'cursor-crosshair', 'cursor-text', 'cursor-pointer');
        
        if (deleteBtnHit) {
            canvas.classList.add('cursor-pointer');
            return;
        }

        if (editMode === 'line') canvas.classList.add('cursor-crosshair');
        else if (editMode === 'text') canvas.classList.add('cursor-text');
        else if (editMode === 'x-mark' || editMode === 'v-mark') canvas.classList.add('cursor-pointer');
    }

    // --- Event Listeners: Settings ---
    fontSizeRange.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        fontSizeVal.innerText = val + 'px';
        styleSettings[editMode].fontSize = val;
        renderCanvas();
    });
    stampSizeRange.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        stampSizeVal.innerText = val + 'px';
        styleSettings[editMode].stampSize = val;
        renderCanvas();
    });
    stampPosRange.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        stampPosVal.innerText = val + 'px';
        styleSettings[editMode].stampPos = val;
        renderCanvas();
    });
    offsetRange.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        offsetVal.innerText = val + 'px';
        styleSettings[editMode].offset = val;
        renderCanvas();
    });

    // --- Zoom & Pan ---
    zoomIn.addEventListener('click', () => updateZoom(0.1));
    zoomOut.addEventListener('click', () => updateZoom(-0.1));
    canvasContainer.addEventListener('wheel', (e) => {
        if (!image) return;
        e.preventDefault();
        updateZoom(-Math.sign(e.deltaY) * 0.1);
    });

    function updateZoom(delta) {
        if (!image) return;
        zoom = Math.min(Math.max(0.05, zoom + delta), 3.0);
        applyTransform();
    }

    function applyTransform() {
        zoomLevel.innerText = Math.round(zoom * 100) + '%';
        canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
        canvas.style.transformOrigin = 'center center';
    }

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !inputModal.style.display.includes('flex') && !helpModal.style.display.includes('flex')) {
            e.preventDefault();
            isSpacePressed = true;
            updateCursor();
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            isSpacePressed = false;
            if (!isHandToolMode) isPanning = false;
            updateCursor();
        }
    });

    // --- Undo / Save / Reset ---
    undoBtn.addEventListener('click', () => { modifications.pop(); renderCanvas(); updateButtons(); });
    
    resetBtn.addEventListener('click', () => {
        if (confirm('모든 수정 사항을 삭제하시겠습니까?')) {
            modifications = [];
            renderCanvas();
            updateButtons();
        }
    });

    saveBtn.addEventListener('click', () => {
        if (!image) return;
        const link = document.createElement('a');
        link.download = '수정계약서_completed.jpg';
        link.href = canvas.toDataURL('image/jpeg', 0.9);
        link.click();
    });

    function updateButtons() {
        undoBtn.disabled = modifications.length === 0;
        resetBtn.disabled = modifications.length === 0;
        saveBtn.disabled = !image;
    }

    // --- Canvas Logic ---
    function initCanvas() {
        if (!image) return;
        canvas.width = image.width;
        canvas.height = image.height;
        
        const scaleX = (canvasContainer.clientWidth - 40) / image.width;
        const scaleY = (canvasContainer.clientHeight - 40) / image.height;
        
        zoom = Math.min(scaleX, scaleY, 1.0);
        if (zoom < 0.1) zoom = 0.1;
        panX = 0; panY = 0;
        
        canvas.classList.remove('hidden');
        canvasContainer.classList.add('loaded'); // Change cursor
        emptyState.classList.add('hidden');
        zoomControls.classList.remove('hidden');
        zoomGuide.classList.remove('hidden');
        setTimeout(() => zoomGuide.classList.add('visible'), 500);
        saveBtn.disabled = false;
        
        setMode(editMode);
        applyTransform();
        renderCanvas();
    }

    function getCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    // Mouse Events
    canvas.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('touchstart', (e) => { if(e.touches.length === 1) handleMouseDown(e); });

    // --- Interaction Logic ---
    function handleMouseDown(e) {
        if (!image) return;

        // 1. Delete Click
        if (hoveredItemId && deleteBtnHit) {
            modifications = modifications.filter(m => m.id !== hoveredItemId);
            hoveredItemId = null;
            deleteBtnHit = false;
            renderCanvas();
            updateButtons();
            return;
        }

        // 2. Pan Start
        if (isSpacePressed || isHandToolMode) {
            isPanning = true;
            panStart = { x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY };
            updateCursor();
            return;
        }

        if (e.button !== 0 && e.type === 'mousedown') return;

        // 3. Draw/Add Start
        const coords = getCoords(e);
        
        if (editMode === 'line') {
            isDrawing = true;
            currentStart = coords;
            currentEnd = coords;
            renderCanvas();
        } else if (editMode === 'text') {
            pendingModification = { type: 'text', position: coords };
            openModal();
        } else if (editMode === 'x-mark' || editMode === 'v-mark') {
            modifications.push({ type: editMode, position: coords, id: Date.now() });
            updateButtons();
            renderCanvas();
        }
    }

    function handleMouseMove(e) {
        if (!image) return;

        // 1. Panning
        if (isPanning) {
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            panX += (clientX - panStart.x);
            panY += (clientY - panStart.y);
            panStart = { x: clientX, y: clientY };
            applyTransform();
            return;
        }

        // 2. Drawing
        if (isDrawing && editMode === 'line') {
            const coords = getCoords(e);
            currentEnd = { x: coords.x, y: currentStart.y };
            renderCanvas();
            return;
        }

        // 3. Hover Detection (Only when not dragging)
        if (!isDrawing && !isPanning) {
            const coords = getCoords(e);
            checkHit(coords);
        }
    }

    function handleMouseUp() {
        if (isPanning) { isPanning = false; updateCursor(); return; }
        if (isDrawing && editMode === 'line') {
            isDrawing = false;
            if (Math.abs(currentEnd.x - currentStart.x) > 10) {
                pendingModification = { type: 'line', start: currentStart, end: currentEnd };
                openModal();
            } else {
                currentStart = null;
                currentEnd = null;
                renderCanvas();
            }
        }
    }

    // --- Hit Testing (Sticky) ---
    function checkHit(coords) {
        if (hoveredItemId) {
            const item = modifications.find(m => m.id === hoveredItemId);
            if (item) {
                const btnPos = getDeleteBtnRect(item);
                const dist = Math.hypot(coords.x - btnPos.cx, coords.y - btnPos.cy);
                if (dist < (60 / zoom)) {
                    deleteBtnHit = (dist < (15 / zoom)); 
                    updateCursor();
                    renderCanvas();
                    return;
                }
            }
        }

        deleteBtnHit = false;
        let found = null;
        const hitThreshold = 15 / zoom; 
        const btnSearchThreshold = 40 / zoom; 

        for (let i = modifications.length - 1; i >= 0; i--) {
            const m = modifications[i];
            const btnPos = getDeleteBtnRect(m);
            
            const distBtn = Math.hypot(coords.x - btnPos.cx, coords.y - btnPos.cy);
            if (distBtn < btnSearchThreshold) {
                found = m.id;
                if (distBtn < (15 / zoom)) deleteBtnHit = true;
                break;
            }

            if (isContentHit(m, coords, hitThreshold)) {
                found = m.id;
                break;
            }
        }

        if (hoveredItemId !== found) {
            hoveredItemId = found;
            renderCanvas();
        }
        updateCursor();
    }

    function isContentHit(m, coords, threshold) {
        const settings = styleSettings[m.type];
        const fSize = settings ? settings.fontSize : 24;
        
        if (m.type === 'line') {
            const dist = distToSegment(coords, m.start, m.end);
            if (dist < threshold) return true;
            if (m.text) {
                const midX = (m.start.x + m.end.x) / 2;
                const off = settings.offset;
                if (Math.abs(coords.x - midX) < 50 && Math.abs(coords.y - (m.start.y - off)) < fSize) return true;
            }
        } else if (m.type === 'text') {
            if (Math.abs(coords.x - m.position.x) < 50 && Math.abs(coords.y - m.position.y) < fSize) return true;
        } else {
            const dist = Math.hypot(coords.x - m.position.x, coords.y - m.position.y);
            if (dist < fSize) return true; 
        }
        return false;
    }

    function distToSegment(p, v, w) {
        const l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
        if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }

    function getDeleteBtnRect(item) {
        let x, y;
        const settings = styleSettings[item.type];
        const fSize = settings ? settings.fontSize : 24;
        const btnPadding = 25 / zoom; 

        if (item.type === 'line') {
            x = Math.max(item.start.x, item.end.x) + btnPadding;
            y = item.start.y - btnPadding;
        } else if (item.type === 'text') {
            ctx.font = `bold ${fSize}px "Noto Sans KR", sans-serif`;
            const width = ctx.measureText(item.text).width;
            x = item.position.x + width + btnPadding;
            y = item.position.y - btnPadding;
        } else {
            x = item.position.x + (fSize * 0.6) + btnPadding;
            y = item.position.y - (fSize * 0.6) - btnPadding;
        }
        return { cx: x, cy: y };
    }

    function renderCanvas() {
        if (!image) return;
        ctx.drawImage(image, 0, 0);

        modifications.forEach(item => {
            ctx.save();
            const settings = styleSettings[item.type];
            const fSize = settings.fontSize;
            const sSize = settings.stampSize;
            const sPos = settings.stampPos;
            const off = settings.offset;

            ctx.font = `bold ${fSize}px "Noto Sans KR", sans-serif`;
            ctx.fillStyle = "#D60000";
            ctx.strokeStyle = "rgba(255, 0, 0, 0.9)";
            ctx.lineWidth = 3;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            if (item.type === 'line') {
                ctx.beginPath(); ctx.moveTo(item.start.x, item.start.y); ctx.lineTo(item.end.x, item.end.y); ctx.stroke();
                const midX = (item.start.x + item.end.x) / 2;
                ctx.textAlign = "center"; ctx.textBaseline = "bottom";
                ctx.fillText(item.text, midX, item.start.y - off);
                drawStamp(ctx, Math.max(item.start.x, item.end.x) + sPos, item.start.y, sSize);
            } else if (item.type === 'text') {
                ctx.textAlign = "left"; ctx.textBaseline = "middle";
                ctx.fillText(item.text, item.position.x, item.position.y);
                const w = ctx.measureText(item.text).width;
                drawStamp(ctx, item.position.x + w + sPos, item.position.y, sSize);
            } else if (item.type === 'x-mark') {
                const s = fSize * 0.8;
                ctx.beginPath(); 
                ctx.moveTo(item.position.x - s, item.position.y - s); ctx.lineTo(item.position.x + s, item.position.y + s);
                ctx.moveTo(item.position.x + s, item.position.y - s); ctx.lineTo(item.position.x - s, item.position.y + s);
                ctx.stroke();
            } else if (item.type === 'v-mark') {
                const s = fSize * 0.8;
                ctx.beginPath();
                ctx.moveTo(item.position.x - s, item.position.y);
                ctx.lineTo(item.position.x - s/3, item.position.y + s);
                ctx.lineTo(item.position.x + s, item.position.y - s * 1.2);
                ctx.stroke();
            }
            ctx.restore();

            if (hoveredItemId === item.id) {
                const btnPos = getDeleteBtnRect(item);
                const btnSize = 20 / zoom; 
                
                ctx.save();
                ctx.translate(btnPos.cx, btnPos.cy);
                ctx.shadowColor = "rgba(0,0,0,0.3)";
                ctx.shadowBlur = 4;
                ctx.beginPath();
                ctx.arc(0, 0, btnSize/2, 0, Math.PI * 2);
                ctx.fillStyle = deleteBtnHit ? "#b91c1c" : "#dc2626"; 
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2 / zoom;
                ctx.stroke();
                ctx.beginPath();
                const xSize = btnSize * 0.3;
                ctx.moveTo(-xSize, -xSize); ctx.lineTo(xSize, xSize);
                ctx.moveTo(xSize, -xSize); ctx.lineTo(-xSize, xSize);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2 / zoom;
                ctx.stroke();
                ctx.restore();
            }
        });

        if (isDrawing && editMode === 'line' && currentStart && currentEnd) {
            ctx.save();
            ctx.beginPath(); ctx.moveTo(currentStart.x, currentStart.y); ctx.lineTo(currentEnd.x, currentEnd.y);
            ctx.strokeStyle = "rgba(255, 0, 0, 0.5)"; ctx.lineWidth = 3; ctx.stroke();
            ctx.restore();
        }
    }

    function drawStamp(ctx, x, y, size) {
        if (stampImage) {
            ctx.drawImage(stampImage, x - size/2, y - size/2, size, size);
        } else {
            ctx.save(); ctx.translate(x, y);
            ctx.beginPath(); ctx.arc(0, 0, size/2, 0, Math.PI*2);
            ctx.strokeStyle="#FF0000"; ctx.lineWidth=2; ctx.stroke();
            ctx.restore();
        }
    }

    function openModal() { textInput.value = ""; inputModal.style.display = 'flex'; setTimeout(() => textInput.focus(), 50); }
    function closeModal() { inputModal.style.display = 'none'; pendingModification = null; currentStart = null; currentEnd = null; renderCanvas(); }
    function confirmInput() {
        const text = textInput.value;
        if (text.trim() !== "" && pendingModification) {
            modifications.push({ ...pendingModification, text: text, id: Date.now() });
            updateButtons();
        }
        closeModal();
    }
    textInput.addEventListener('input', (e) => { 
        const v = e.target.value.replace(/,/g, '');
        if(!isNaN(v) && v !== '') e.target.value = Number(v).toLocaleString();
    });
    textInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') confirmInput(); });
    modalCancel.addEventListener('click', closeModal);
    modalConfirm.addEventListener('click', confirmInput);
</script>

</body>
</html>
